import { __decorate, __metadata, __spread, __assign } from 'tslib';
import { CommonModule } from '@angular/common';
import { Injectable, EventEmitter, ViewChild, Input, Output, HostListener, Component, ChangeDetectionStrategy, ChangeDetectorRef, TemplateRef, ContentChild, Pipe, NgModule } from '@angular/core';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import { PaginationControlsDirective, NgxPaginationModule } from 'ngx-pagination';
import { from, Subject } from 'rxjs';
import { groupBy, flatMap, reduce, takeUntil, throttleTime, filter } from 'rxjs/operators';
import { ScrollDispatcher, CdkVirtualScrollViewport, ScrollingModule } from '@angular/cdk/scrolling';

var STYLE;
(function (STYLE) {
    STYLE["TINY"] = "tiny";
    STYLE["BIG"] = "big";
    STYLE["NORMAL"] = "normal";
})(STYLE || (STYLE = {}));
var THEME;
(function (THEME) {
    THEME["LIGHT"] = "light";
    THEME["DARK"] = "dark";
})(THEME || (THEME = {}));

var Event;
(function (Event) {
    Event["onPagination"] = "onPagination";
    Event["onOrder"] = "onOrder";
    Event["onGlobalSearch"] = "onGlobalSearch";
    Event["onSearch"] = "onSearch";
    Event["onClick"] = "onClick";
    Event["onDoubleClick"] = "onDoubleClick";
    Event["onCheckboxSelect"] = "onCheckboxSelect";
    Event["onRadioSelect"] = "onRadioSelect";
    Event["onCheckboxToggle"] = "onCheckboxToggle";
    Event["onSelectAll"] = "onSelectAll";
    Event["onInfiniteScrollEnd"] = "onInfiniteScrollEnd";
    Event["onColumnResizeMouseDown"] = "onColumnResizeMouseDown";
    Event["onColumnResizeMouseUp"] = "onColumnResizeMouseUp";
    Event["onRowDrop"] = "onRowDrop";
    Event["onRowCollapsedShow"] = "onRowCollapsedShow";
    Event["onRowCollapsedHide"] = "onRowCollapsedHide";
    Event["onRowContextMenu"] = "onRowContextMenu";
})(Event || (Event = {}));

var API;
(function (API) {
    API["rowContextMenuClicked"] = "rowContextMenuClicked";
    API["setInputValue"] = "setInputValue";
    API["toolPanelClicked"] = "toolPanelClicked";
    API["toggleRowIndex"] = "toggleRowIndex";
    API["toggleCheckbox"] = "toggleCheckbox";
    API["onGlobalSearch"] = "onGlobalSearch";
    API["setPaginationCurrentPage"] = "setPaginationCurrentPage";
    API["getPaginationCurrentPage"] = "getPaginationCurrentPage";
    API["getPaginationTotalItems"] = "getPaginationTotalItems";
    API["getNumberOfRowsPerPage"] = "getNumberOfRowsPerPage";
    API["getPaginationLastPage"] = "getPaginationLastPage";
    API["setPaginationRange"] = "setPaginationRange";
    API["setPaginationPreviousLabel"] = "setPaginationPreviousLabel";
    API["setPaginationNextLabel"] = "setPaginationNextLabel";
    API["setPaginationDisplayLimit"] = "setPaginationDisplayLimit";
    API["setTableClass"] = "setTableClass";
    API["setRowClass"] = "setRowClass";
    API["setCellClass"] = "setCellClass";
    API["setRowStyle"] = "setRowStyle";
    API["setCellStyle"] = "setCellStyle";
    API["sortBy"] = "sortBy";
})(API || (API = {}));

var DefaultConfig = {
    searchEnabled: false,
    headerEnabled: true,
    orderEnabled: true,
    orderEventOnly: false,
    paginationEnabled: true,
    exportEnabled: false,
    clickEvent: true,
    selectRow: false,
    selectCol: false,
    selectCell: false,
    rows: 10,
    additionalActions: false,
    serverPagination: false,
    isLoading: false,
    detailsTemplate: false,
    groupRows: false,
    paginationRangeEnabled: true,
    collapseAllRows: false,
    checkboxes: false,
    radio: false,
    resizeColumn: false,
    fixedColumnWidth: true,
    horizontalScroll: false,
    draggable: false,
    logger: false,
    showDetailsArrow: false,
    showContextMenu: false,
    persistState: false,
    paginationMaxSize: 5,
    threeWaySort: false,
    tableLayout: {
        style: STYLE.NORMAL,
        theme: THEME.LIGHT,
        borderless: false,
        hover: true,
        striped: false,
    },
};
var DefaultConfigService = /** @class */ (function () {
    function DefaultConfigService() {
    }
    DefaultConfigService.config = DefaultConfig;
    DefaultConfigService = __decorate([
        Injectable()
    ], DefaultConfigService);
    return DefaultConfigService;
}());

var PaginationComponent = /** @class */ (function () {
    function PaginationComponent() {
        this.updateRange = new EventEmitter();
        this.ranges = [5, 10, 25, 50, 100];
        this.showRange = false;
        this.screenReaderPaginationLabel = 'Pagination';
        this.screenReaderPageLabel = 'page';
        this.screenReaderCurrentLabel = 'You are on page';
        this.previousLabel = '';
        this.nextLabel = '';
        this.directionLinks = true;
    }
    PaginationComponent.prototype.onClick = function (targetElement) {
        if (this.paginationRange && !this.paginationRange.nativeElement.contains(targetElement)) {
            this.showRange = false;
        }
    };
    PaginationComponent.prototype.ngOnChanges = function (changes) {
        var config = changes.config;
        if (config && config.currentValue) {
            this.selectedLimit = this.config.rows;
        }
    };
    PaginationComponent.prototype.onPageChange = function (page) {
        this.updateRange.emit({
            page: page,
            limit: this.selectedLimit,
        });
    };
    PaginationComponent.prototype.changeLimit = function (limit, callFromAPI) {
        if (!callFromAPI) {
            this.showRange = !this.showRange;
        }
        this.selectedLimit = limit;
        this.updateRange.emit({
            page: 1,
            limit: limit,
        });
    };
    __decorate([
        ViewChild('paginationDirective', { static: true }),
        __metadata("design:type", PaginationControlsDirective)
    ], PaginationComponent.prototype, "paginationDirective", void 0);
    __decorate([
        ViewChild('paginationRange'),
        __metadata("design:type", Object)
    ], PaginationComponent.prototype, "paginationRange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PaginationComponent.prototype, "pagination", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PaginationComponent.prototype, "config", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PaginationComponent.prototype, "id", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PaginationComponent.prototype, "updateRange", void 0);
    __decorate([
        HostListener('document:click', ['$event.target']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], PaginationComponent.prototype, "onClick", null);
    PaginationComponent = __decorate([
        Component({
            selector: 'pagination',
            template: "<div class=\"ngx-pagination-wrapper\"\n     [style.display]=\"config.paginationEnabled ? '' : 'none'\"\n     [class.ngx-table__table--dark-pagination-wrapper]=\"config.tableLayout.theme === 'dark'\">\n  <div class=\"ngx-pagination-steps\">\n    <pagination-template\n      #paginationDirective=\"paginationApi\"\n      id=\"pagination-controls\"\n      [id]=\"id\"\n      [class.ngx-table__table--dark-pagination]=\"config.tableLayout.theme === 'dark'\"\n      [maxSize]=\"config.paginationMaxSize || 5\"\n      (pageChange)=\"onPageChange($event)\">\n      <ul class=\"ngx-pagination\"\n          role=\"navigation\"\n          [attr.aria-label]=\"screenReaderPaginationLabel\"\n          [class.responsive]=\"true\">\n        <li class=\"pagination-previous\" [class.disabled]=\"paginationDirective.isFirstPage()\" *ngIf=\"directionLinks\">\n          <a tabindex=\"0\" *ngIf=\"1 < paginationDirective.getCurrent()\" (keyup.enter)=\"paginationDirective.previous()\"\n             (click)=\"paginationDirective.previous()\"\n             [attr.aria-label]=\"previousLabel + ' ' + screenReaderPageLabel\">\n            {{ previousLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n          </a>\n          <span *ngIf=\"paginationDirective.isFirstPage()\">\n                {{ previousLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n            </span>\n        </li>\n        <li class=\"small-screen\">\n          {{ paginationDirective.getCurrent() }} / {{ paginationDirective.getLastPage() }}\n        </li>\n        <li [class.current]=\"paginationDirective.getCurrent() === page.value\"\n            [class.ellipsis]=\"page.label === '...'\"\n            *ngFor=\"let page of paginationDirective.pages\">\n          <a tabindex=\"0\" (keyup.enter)=\"paginationDirective.setCurrent(page.value)\"\n             (click)=\"paginationDirective.setCurrent(page.value)\"\n             *ngIf=\"paginationDirective.getCurrent() !== page.value\">\n            <span class=\"show-for-sr\">{{ screenReaderPageLabel }} </span>\n            <span>{{ page.label }}</span>\n          </a>\n          <ng-container *ngIf=\"paginationDirective.getCurrent() === page.value\">\n            <span class=\"show-for-sr\">{{ screenReaderCurrentLabel }} </span>\n            <span>{{ page.label }}</span>\n          </ng-container>\n        </li>\n        <li class=\"pagination-next\" [class.disabled]=\"paginationDirective.isLastPage()\" *ngIf=\"directionLinks\">\n          <a tabindex=\"0\" *ngIf=\"!paginationDirective.isLastPage()\" (keyup.enter)=\"paginationDirective.next()\"\n             (click)=\"paginationDirective.next()\"\n             [attr.aria-label]=\"nextLabel + ' ' + screenReaderPageLabel\">\n            {{ nextLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n          </a>\n          <span *ngIf=\"paginationDirective.isLastPage()\">\n                 {{ nextLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n            </span>\n        </li>\n      </ul>\n    </pagination-template>\n  </div>\n  <div class=\"ngx-pagination-range\"\n       #paginationRange\n       [class.ngx-table__table--dark-pagination-range]=\"config.tableLayout.theme === 'dark'\"\n       *ngIf=\"config.paginationRangeEnabled\">\n    <div class=\"ngx-dropdown ngx-pagination-range-dropdown\"\n         id=\"rowAmount\">\n      <div class=\"ngx-btn-group\">\n        <div class=\"ngx-pagination-range-dropdown-button\"\n             (click)=\"showRange = !showRange\">\n          {{selectedLimit}} <i class=\"ngx-icon ngx-icon-arrow-down\"></i>\n        </div>\n        <ul class=\"ngx-menu\" *ngIf=\"showRange\">\n          <li class=\"ngx-pagination-range-dropdown-button-item\"\n              [class.ngx-pagination-range--selected]=\"limit === selectedLimit\"\n              (click)=\"changeLimit(limit, false)\"\n              *ngFor=\"let limit of ranges\">\n            <span>{{limit}}</span>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</div>\n",
            changeDetection: ChangeDetectionStrategy.OnPush
        })
    ], PaginationComponent);
    return PaginationComponent;
}());

var GroupRowsService = /** @class */ (function () {
    function GroupRowsService() {
    }
    GroupRowsService.doGroupRows = function (data, groupRowsBy) {
        var grouped = [];
        from(data).pipe(groupBy(function (row) { return row[groupRowsBy]; }), flatMap(function (group) { return group.pipe(reduce(function (acc, curr) { return __spread(acc, [curr]); }, [])); })).subscribe(function (row) { return grouped.push(row); });
        return grouped;
    };
    GroupRowsService = __decorate([
        Injectable()
    ], GroupRowsService);
    return GroupRowsService;
}());

/* tslint:disable:no-useless-cast */
var StyleService = /** @class */ (function () {
    function StyleService() {
    }
    StyleService.prototype.setRowClass = function (val) {
        var selector = "#table > tbody > tr:nth-child(" + val.row + ")";
        var row = document.querySelector(selector);
        if (row) {
            row.classList.add(val.className);
        }
    };
    StyleService.prototype.setCellClass = function (val) {
        var selector = "#table > tbody > tr:nth-child(" + val.row + ") > td:nth-child(" + val.cell + ")";
        var cell = document.querySelector(selector);
        if (cell) {
            cell.classList.add(val.className);
        }
    };
    StyleService.prototype.setRowStyle = function (val) {
        var selector = "#table > tbody > tr:nth-child(" + val.row + ")";
        var row = document.querySelector(selector);
        if (row) {
            // tslint:disable-next-line:no-string-literal
            row.style[val.attr] = val.value;
        }
    };
    StyleService.prototype.setCellStyle = function (val) {
        var selector = "#table > tbody > tr:nth-child(" + val.row + ") > td:nth-child(" + val.cell + ")";
        var cell = document.querySelector(selector);
        if (cell) {
            // tslint:disable-next-line:no-string-literal
            cell.style[val.attr] = val.value;
        }
    };
    StyleService.prototype.pinnedWidth = function (pinned, column) {
        if (pinned) {
            return 150 * column + 'px';
        }
    };
    StyleService = __decorate([
        Injectable()
    ], StyleService);
    return StyleService;
}());

var BaseComponent = /** @class */ (function () {
    function BaseComponent(cdr, scrollDispatcher, styleService) {
        var _this = this;
        this.cdr = cdr;
        this.scrollDispatcher = scrollDispatcher;
        this.styleService = styleService;
        this.unsubscribe = new Subject();
        this.filterCount = -1;
        this.filteredCountSubject = new Subject();
        this.tableClass = null;
        this.grouped = [];
        this.isSelected = false;
        this.page = 1;
        this.count = 0;
        this.sortState = new Map();
        this.sortKey = null;
        this.rowContextMenuPosition = {
            top: null,
            left: null,
            value: null,
        };
        this.sortBy = {
            key: '',
            order: 'asc',
        };
        this.selectedDetailsTemplateRowId = new Set();
        this.selectedCheckboxes = new Set();
        this.id = 'table';
        this.event = new EventEmitter();
        this.filteredCountSubject
            .pipe(takeUntil(this.unsubscribe))
            .subscribe(function (count) {
            setTimeout(function () {
                _this.filterCount = count;
                _this.cdr.detectChanges();
            });
        });
    }
    BaseComponent.prototype.onContextMenuClick = function (targetElement) {
        if (this.contextMenu && !this.contextMenu.nativeElement.contains(targetElement)) {
            this.rowContextMenuPosition = {
                top: null,
                left: null,
                value: null,
            };
        }
    };
    BaseComponent.prototype.ngOnInit = function () {
        if (!this.columns) {
            console.error('[columns] property required!');
        }
        if (this.configuration) {
            this.config = this.configuration;
        }
        else {
            this.config = DefaultConfigService.config;
        }
        this.limit = this.config.rows;
        if (this.groupRowsBy) {
            this.grouped = GroupRowsService.doGroupRows(this.data, this.groupRowsBy);
        }
        this.doDecodePersistedState();
    };
    BaseComponent.prototype.ngOnDestroy = function () {
        this.unsubscribe.next();
        this.unsubscribe.complete();
    };
    BaseComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var throttleValue = this.config.infiniteScrollThrottleTime ?
            this.config.infiniteScrollThrottleTime :
            200;
        this.scrollDispatcher.scrolled()
            .pipe(takeUntil(this.unsubscribe), throttleTime(throttleValue), filter(function (event) {
            return !!event && _this.viewPort && _this.viewPort.getRenderedRange().end === _this.viewPort.getDataLength();
        }))
            .subscribe(function () {
            _this.emitEvent(Event.onInfiniteScrollEnd, null);
        });
    };
    BaseComponent.prototype.ngOnChanges = function (changes) {
        var configuration = changes.configuration, data = changes.data, pagination = changes.pagination, groupRowsBy = changes.groupRowsBy;
        this.toggleRowIndex = changes.toggleRowIndex;
        if (configuration && configuration.currentValue) {
            this.config = configuration.currentValue;
        }
        if (data && data.currentValue) {
            this.doApplyData(data);
        }
        if (pagination && pagination.currentValue) {
            var _a = pagination.currentValue, count = _a.count, limit = _a.limit, offset = _a.offset;
            this.count = count;
            this.limit = limit;
            this.page = offset;
        }
        if (groupRowsBy && groupRowsBy.currentValue) {
            this.grouped = GroupRowsService.doGroupRows(this.data, this.groupRowsBy);
        }
        if (this.toggleRowIndex && this.toggleRowIndex.currentValue) {
            var row = this.toggleRowIndex.currentValue;
            this.collapseRow(row.index);
        }
    };
    BaseComponent.prototype.orderBy = function (column) {
        if (typeof column.orderEnabled !== 'undefined' && !column.orderEnabled) {
            return;
        }
        this.sortKey = column.key;
        if (!this.config.orderEnabled || this.sortKey === '') {
            return;
        }
        this.setColumnOrder(this.sortKey);
        if (!this.config.orderEventOnly && !column.orderEventOnly) {
            this.sortBy.key = this.sortKey;
            this.sortBy.order = this.sortState.get(this.sortKey);
        }
        else {
            this.sortBy.key = '';
            this.sortBy.order = '';
        }
        if (!this.config.serverPagination) {
            this.data = __spread(this.data);
            this.sortBy = __assign({}, this.sortBy);
        }
        var value = {
            key: this.sortKey,
            order: this.sortState.get(this.sortKey),
        };
        this.emitEvent(Event.onOrder, value);
    };
    BaseComponent.prototype.onClick = function ($event, row, key, colIndex, rowIndex) {
        if (this.config.selectRow) {
            this.selectedRow = rowIndex;
        }
        if (this.config.selectCol && colIndex) {
            this.selectedCol = colIndex;
        }
        if (this.config.selectCell && colIndex) {
            this.selectedRow = rowIndex;
            this.selectedCol = colIndex;
        }
        if (this.config.clickEvent) {
            var value = {
                event: $event,
                row: row,
                key: key,
                rowId: rowIndex,
                colId: colIndex,
            };
            this.emitEvent(Event.onClick, value);
        }
    };
    BaseComponent.prototype.onDoubleClick = function ($event, row, key, colIndex, rowIndex) {
        var value = {
            event: $event,
            row: row,
            key: key,
            rowId: rowIndex,
            colId: colIndex,
        };
        this.emitEvent(Event.onDoubleClick, value);
    };
    BaseComponent.prototype.onCheckboxSelect = function ($event, row, rowIndex) {
        var value = {
            event: $event,
            row: row,
            rowId: rowIndex,
        };
        this.emitEvent(Event.onCheckboxSelect, value);
    };
    BaseComponent.prototype.onRadioSelect = function ($event, row, rowIndex) {
        var value = {
            event: $event,
            row: row,
            rowId: rowIndex,
        };
        this.emitEvent(Event.onRadioSelect, value);
    };
    BaseComponent.prototype.onSelectAll = function () {
        this.isSelected = !this.isSelected;
        this.emitEvent(Event.onSelectAll, this.isSelected);
    };
    BaseComponent.prototype.onSearch = function ($event) {
        if (!this.config.serverPagination) {
            this.term = $event;
        }
        this.emitEvent(Event.onSearch, $event);
    };
    BaseComponent.prototype.onGlobalSearch = function (value) {
        if (!this.config.serverPagination) {
            this.globalSearchTerm = value;
        }
        this.emitEvent(Event.onGlobalSearch, value);
    };
    BaseComponent.prototype.onPagination = function (pagination) {
        this.page = pagination.page;
        this.limit = pagination.limit;
        this.emitEvent(Event.onPagination, pagination);
    };
    BaseComponent.prototype.toggleCheckbox = function (rowIndex) {
        this.selectedCheckboxes.has(rowIndex) ?
            this.selectedCheckboxes.delete(rowIndex) :
            this.selectedCheckboxes.add(rowIndex);
    };
    BaseComponent.prototype.collapseRow = function (rowIndex) {
        if (this.selectedDetailsTemplateRowId.has(rowIndex)) {
            this.selectedDetailsTemplateRowId.delete(rowIndex);
            this.emitEvent(Event.onRowCollapsedHide, rowIndex);
        }
        else {
            this.selectedDetailsTemplateRowId.add(rowIndex);
            this.emitEvent(Event.onRowCollapsedShow, rowIndex);
        }
    };
    BaseComponent.prototype.doDecodePersistedState = function () {
        if (!this.config.persistState) {
            return;
        }
        var pagination = localStorage.getItem(Event.onPagination);
        var sort = localStorage.getItem(Event.onOrder);
        var search = localStorage.getItem(Event.onSearch);
        if (pagination) {
            this.onPagination(JSON.parse(pagination));
        }
        if (sort) {
            var _a = JSON.parse(sort), key = _a.key, order = _a.order;
            this.bindApi({
                type: API.sortBy,
                value: { column: key, order: order },
            });
        }
        if (search) {
            this.bindApi({
                type: API.setInputValue,
                value: JSON.parse(search),
            });
        }
    };
    BaseComponent.prototype.isRowCollapsed = function (rowIndex) {
        if (this.config.collapseAllRows) {
            return true;
        }
        return this.selectedDetailsTemplateRowId.has(rowIndex);
    };
    Object.defineProperty(BaseComponent.prototype, "loadingHeight", {
        get: function () {
            var table = document.getElementById(this.id);
            if (table && table.rows && table.rows.length > 3) {
                var searchEnabled = this.config.searchEnabled ? 1 : 0;
                var headerEnabled = this.config.headerEnabled ? 1 : 0;
                var borderTrHeight = 1;
                var borderDivHeight = 2;
                return (table.rows.length - searchEnabled - headerEnabled) * (table.rows[3].offsetHeight - borderTrHeight) - borderDivHeight;
            }
            return 30;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseComponent.prototype, "arrowDefinition", {
        get: function () {
            return this.config.showDetailsArrow || typeof this.config.showDetailsArrow === 'undefined';
        },
        enumerable: true,
        configurable: true
    });
    BaseComponent.prototype.onRowContextMenu = function ($event, row, key, colIndex, rowIndex) {
        if (!this.config.showContextMenu) {
            return;
        }
        $event.preventDefault();
        var value = {
            event: $event,
            row: row,
            key: key,
            rowId: rowIndex,
            colId: colIndex,
        };
        this.rowContextMenuPosition = {
            top: $event.y - 10 + "px",
            left: $event.x - 10 + "px",
            value: value,
        };
        this.emitEvent(Event.onRowContextMenu, value);
    };
    BaseComponent.prototype.doApplyData = function (data) {
        var order = this.columns.find(function (c) { return !!c.orderBy; });
        if (order) {
            this.sortState.set(this.sortKey, (order.orderBy === 'asc') ? 'desc' : 'asc');
            this.orderBy(order);
        }
        else {
            this.data = __spread(data.currentValue);
        }
    };
    BaseComponent.prototype.onDrop = function (event) {
        this.emitEvent(Event.onRowDrop, event);
        moveItemInArray(this.data, event.previousIndex, event.currentIndex);
    };
    // DO NOT REMOVE. It is called from parent component. See src/app/demo/api-doc/api-doc.component.ts
    BaseComponent.prototype.apiEvent = function (event) {
        return this.bindApi(event);
    };
    // tslint:disable:no-big-function cognitive-complexity
    BaseComponent.prototype.bindApi = function (event) {
        var _this = this;
        switch (event.type) {
            case API.rowContextMenuClicked:
                this.rowContextMenuPosition = {
                    top: null,
                    left: null,
                    value: null,
                };
                break;
            case API.toolPanelClicked:
                // TODO
                break;
            case API.toggleRowIndex:
                this.collapseRow(event.value);
                break;
            case API.toggleCheckbox:
                this.toggleCheckbox(event.value);
                break;
            case API.setInputValue:
                if (this.config.searchEnabled) {
                    event.value.forEach(function (input) {
                        var element = document.getElementById("search_" + input.key);
                        if (!element) {
                            console.error("Column '" + input.key + "' not available in the DOM. Have you misspelled a name?");
                        }
                        else {
                            element.value = input.value;
                        }
                    });
                }
                this.onSearch(event.value);
                this.cdr.detectChanges();
                break;
            case API.onGlobalSearch:
                this.onGlobalSearch(event.value);
                this.cdr.detectChanges();
                break;
            case API.setRowClass:
                if (Array.isArray(event.value)) {
                    event.value.forEach(function (val) { return _this.styleService.setRowClass(val); });
                    break;
                }
                this.styleService.setRowClass(event.value);
                this.cdr.detectChanges();
                break;
            case API.setCellClass:
                if (Array.isArray(event.value)) {
                    event.value.forEach(function (val) { return _this.styleService.setCellClass(val); });
                    break;
                }
                this.styleService.setCellClass(event.value);
                break;
            case API.setRowStyle:
                if (Array.isArray(event.value)) {
                    event.value.forEach(function (val) { return _this.styleService.setRowStyle(val); });
                    break;
                }
                this.styleService.setRowStyle(event.value);
                break;
            case API.setCellStyle:
                if (Array.isArray(event.value)) {
                    event.value.forEach(function (val) { return _this.styleService.setCellStyle(val); });
                    break;
                }
                this.styleService.setCellStyle(event.value);
                break;
            case API.setTableClass:
                this.tableClass = event.value;
                this.cdr.detectChanges();
                break;
            case API.getPaginationTotalItems:
                return this.paginationComponent.paginationDirective.getTotalItems();
            case API.getPaginationCurrentPage:
                return this.paginationComponent.paginationDirective.getCurrent();
            case API.getPaginationLastPage:
                return this.paginationComponent.paginationDirective.getLastPage();
            case API.getNumberOfRowsPerPage:
                return this.paginationComponent.paginationDirective.isLastPage() ?
                    (this.paginationComponent.paginationDirective.getTotalItems() % this.limit) :
                    this.limit;
            case API.setPaginationCurrentPage:
                this.paginationComponent.paginationDirective.setCurrent(event.value);
                break;
            case API.setPaginationRange:
                this.paginationComponent.ranges = event.value;
                break;
            case API.setPaginationPreviousLabel:
                this.paginationComponent.previousLabel = event.value;
                break;
            case API.setPaginationNextLabel:
                this.paginationComponent.nextLabel = event.value;
                break;
            case API.setPaginationDisplayLimit:
                this.paginationComponent.changeLimit(event.value, true);
                break;
            case API.sortBy:
                var column = { title: '', key: event.value.column, orderBy: event.value.order };
                this.orderBy(column);
                this.cdr.detectChanges();
                break;
            default:
                break;
        }
    };
    BaseComponent.prototype.setColumnOrder = function (key) {
        switch (this.sortState.get(key)) {
            case '':
            case undefined:
                this.sortState.set(key, 'desc');
                break;
            case 'asc':
                this.config.threeWaySort ?
                    this.sortState.set(key, '') :
                    this.sortState.set(key, 'desc');
                break;
            case 'desc':
                this.sortState.set(key, 'asc');
                break;
        }
        if (this.sortState.size > 1) {
            var temp = this.sortState.get(key);
            this.sortState.clear();
            this.sortState.set(key, temp);
        }
    };
    BaseComponent.prototype.emitEvent = function (event, value) {
        this.event.emit({ event: event, value: value });
        if (this.config.persistState) {
            localStorage.setItem(event, JSON.stringify(value));
        }
        if (this.config.logger) {
            // tslint:disable-next-line:no-console
            console.log({ event: event, value: value });
        }
    };
    BaseComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ScrollDispatcher },
        { type: StyleService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseComponent.prototype, "configuration", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BaseComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseComponent.prototype, "pagination", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BaseComponent.prototype, "groupRowsBy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseComponent.prototype, "id", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseComponent.prototype, "toggleRowIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "detailsTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "summaryTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "groupRowsHeaderTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "filtersTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "selectAllTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "noResultsTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "loadingTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "additionalActionsTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "rowContextMenu", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BaseComponent.prototype, "columns", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BaseComponent.prototype, "event", void 0);
    __decorate([
        ContentChild(TemplateRef, { static: true }),
        __metadata("design:type", TemplateRef)
    ], BaseComponent.prototype, "rowTemplate", void 0);
    __decorate([
        ViewChild('paginationComponent'),
        __metadata("design:type", PaginationComponent)
    ], BaseComponent.prototype, "paginationComponent", void 0);
    __decorate([
        ViewChild('contextMenu'),
        __metadata("design:type", Object)
    ], BaseComponent.prototype, "contextMenu", void 0);
    __decorate([
        ViewChild(CdkVirtualScrollViewport),
        __metadata("design:type", CdkVirtualScrollViewport)
    ], BaseComponent.prototype, "viewPort", void 0);
    __decorate([
        HostListener('document:click', ['$event.target']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], BaseComponent.prototype, "onContextMenuClick", null);
    BaseComponent = __decorate([
        Component({
            selector: 'ngx-table',
            providers: [
                DefaultConfigService,
                GroupRowsService,
                StyleService,
            ],
            template: "<div class=\"ngx-container\">\n  <table\n    [id]=\"id\"\n    [ngClass]=\"tableClass === null || tableClass === '' ? 'ngx-table' : tableClass\"\n    [class.ngx-table__table--tiny]=\"config.tableLayout.style === 'tiny'\"\n    [class.ngx-table__table--normal]=\"config.tableLayout.style === 'normal'\"\n    [class.ngx-table__table--big]=\"config.tableLayout.style === 'big'\"\n    [class.ngx-table__table--borderless]=\"config.tableLayout.borderless\"\n    [class.ngx-table__table--dark]=\"config.tableLayout.theme === 'dark'\"\n    [class.ngx-table__table--hoverable]=\"config.tableLayout.hover\"\n    [class.ngx-table__table--striped]=\"config.tableLayout.striped\"\n    [class.ngx-table__horizontal-scroll]=\"config.horizontalScroll && !config.isLoading\"\n  >\n    <thead\n      [class.ngx-infinite-scroll-viewport-thead]=\"config.infiniteScroll\"\n      table-thead\n      [config]=\"config\"\n      [sortKey]=\"sortKey\"\n      [sortState]=\"sortState\"\n      [selectAllTemplate]=\"selectAllTemplate\"\n      [filtersTemplate]=\"filtersTemplate\"\n      [additionalActionsTemplate]=\"additionalActionsTemplate\"\n      [columns]=\"columns\"\n      (selectAll)=\"onSelectAll()\"\n      (filter)=\"onSearch($event)\"\n      (order)=\"orderBy($event)\"\n      (event)=\"emitEvent($event.event, $event.value)\"\n    ></thead>\n    <tbody *ngIf=\"data && !config.isLoading && !config.rowReorder\">\n      <ng-container *ngIf=\"rowTemplate\">\n        <ul\n          class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{\n            position: 'absolute',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }\"\n          *ngIf=\"rowContextMenuPosition.top\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"rowContextMenu\"\n            [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value }\"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf=\"!config.infiniteScroll\">\n          <ng-container\n            *ngFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n              let rowIndex = index\n            \"\n          >\n            <tr\n              (click)=\"onClick($event, row, '', null, rowIndex)\"\n              #contextMenu\n              (contextmenu)=\"onRowContextMenu($event, row, '', null, rowIndex)\"\n              (dblclick)=\"onDoubleClick($event, row, '', null, rowIndex)\"\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <ng-container\n                [ngTemplateOutlet]=\"rowTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n              >\n              </ng-container>\n              <td *ngIf=\"config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        <cdk-virtual-scroll-viewport\n          itemSize=\"50\"\n          *ngIf=\"config.infiniteScroll\"\n          class=\"ngx-infinite-scroll-viewport\"\n        >\n          <ng-container\n            *cdkVirtualFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            \"\n          >\n            <tr\n              (click)=\"onClick($event, row, '', null, rowIndex)\"\n              #contextMenu\n              (contextmenu)=\"onRowContextMenu($event, row, '', null, rowIndex)\"\n              (dblclick)=\"onDoubleClick($event, row, '', null, rowIndex)\"\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <ng-container\n                [ngTemplateOutlet]=\"rowTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n              >\n              </ng-container>\n              <td *ngIf=\"config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n        <ul\n          class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{\n            position: 'absolute',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }\"\n          *ngIf=\"rowContextMenuPosition.top\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"rowContextMenu\"\n            [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value }\"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf=\"!config.infiniteScroll\">\n          <ng-container\n            *ngFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n              let rowIndex = index\n            \"\n          >\n            <tr\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <td *ngIf=\"config.checkboxes\">\n                <label class=\"ngx-form-checkbox\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"checkbox-{{ rowIndex }}\"\n                    [checked]=\"isSelected || selectedCheckboxes.has(rowIndex)\"\n                    (change)=\"onCheckboxSelect($event, row, rowIndex)\"\n                  />\n                  <em class=\"ngx-form-icon\"></em>\n                </label>\n              </td>\n              <td *ngIf=\"config.radio\">\n                <label>\n                  <input\n                    type=\"radio\"\n                    id=\"radio-{{ rowIndex }}\"\n                    name=\"radio\"\n                    (change)=\"onRadioSelect($event, row, rowIndex)\"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n                <td\n                  (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                  #contextMenu\n                  (contextmenu)=\"onRowContextMenu($event, row, column.key, colIndex, rowIndex)\"\n                  (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                  [class.pinned-left]=\"column.pinned\"\n                  [ngClass]=\"column.cssClass ? column.cssClass.name : ''\"\n                  [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n                  [class.ngx-table__table-col--selected]=\"\n                    colIndex === selectedCol && !config.selectCell\n                  \"\n                  [class.ngx-table__table-cell--selected]=\"\n                    colIndex === selectedCol &&\n                    rowIndex === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  \"\n                >\n                  <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf=\"column.cellTemplate\"\n                    [ngTemplateOutlet]=\"column.cellTemplate\"\n                    [ngTemplateOutletContext]=\"{\n                      $implicit: row,\n                      rowIndex: rowIndex,\n                      column: column\n                    }\"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf=\"config.additionalActions || config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td *ngIf=\"config.checkboxes || config.radio\"></td>\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        <!-- infinite scroll -->\n        <cdk-virtual-scroll-viewport\n          itemSize=\"50\"\n          *ngIf=\"config.infiniteScroll\"\n          class=\"ngx-infinite-scroll-viewport\"\n        >\n          <ng-container\n            *cdkVirtualFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            \"\n          >\n            <tr\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <td *ngIf=\"config.checkboxes\">\n                <label class=\"ngx-form-checkbox\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"checkbox-infinite-scroll-{{ rowIndex }}\"\n                    [checked]=\"isSelected || selectedCheckboxes.has(rowIndex)\"\n                    (change)=\"onCheckboxSelect($event, row, rowIndex)\"\n                  />\n                  <em class=\"ngx-form-icon\"></em>\n                </label>\n              </td>\n              <td *ngIf=\"config.radio\">\n                <label>\n                  <input\n                    type=\"radio\"\n                    id=\"radio-infinite-scroll-{{ rowIndex }}\"\n                    name=\"radio\"\n                    (change)=\"onRadioSelect($event, row, rowIndex)\"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n                <td\n                  (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                  #contextMenu\n                  (contextmenu)=\"onRowContextMenu($event, row, column.key, colIndex, rowIndex)\"\n                  (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                  [class.pinned-left]=\"column.pinned\"\n                  [ngClass]=\"column.cssClass ? column.cssClass.name : ''\"\n                  [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n                  [class.ngx-table__table-col--selected]=\"\n                    colIndex === selectedCol && !config.selectCell\n                  \"\n                  [class.ngx-table__table-cell--selected]=\"\n                    colIndex === selectedCol &&\n                    rowIndex === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  \"\n                >\n                  <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf=\"column.cellTemplate\"\n                    [ngTemplateOutlet]=\"column.cellTemplate\"\n                    [ngTemplateOutletContext]=\"{\n                      $implicit: row,\n                      rowIndex: rowIndex,\n                      column: column\n                    }\"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf=\"config.additionalActions || config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td *ngIf=\"config.checkboxes || config.radio\"></td>\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf=\"!rowTemplate && config.groupRows\">\n        <ng-container\n          *ngFor=\"\n            let group of grouped\n              | sort: sortBy:config\n              | search: term:filteredCountSubject:config\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n            let rowIndex = index\n          \"\n        >\n          <tr>\n            <ng-container *ngIf=\"!groupRowsHeaderTemplate\">\n              <td [attr.colspan]=\"columns.length\">\n                <div>{{ group[0][groupRowsBy] }} ({{ group.length }})</div>\n              </td>\n            </ng-container>\n            <ng-container\n              *ngIf=\"groupRowsHeaderTemplate\"\n              [ngTemplateOutlet]=\"groupRowsHeaderTemplate\"\n              [ngTemplateOutletContext]=\"{\n                total: group.length,\n                key: groupRowsBy,\n                value: group[0] ? group[0][groupRowsBy] : '',\n                group: group,\n                index: rowIndex\n              }\"\n            >\n            </ng-container>\n            <td>\n              <span\n                class=\"ngx-icon\"\n                *ngIf=\"arrowDefinition\"\n                [ngClass]=\"\n                  isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                \"\n                (click)=\"collapseRow(rowIndex)\"\n              >\n              </span>\n            </td>\n          </tr>\n          <ng-container *ngIf=\"selectedDetailsTemplateRowId.has(rowIndex)\">\n            <tr *ngFor=\"let row of group\">\n              <td *ngFor=\"let column of columns\">\n                {{ row | render: column.key }}\n                <!-- TODO allow users to add groupRowsTemplateRef -->\n              </td>\n              <td></td>\n            </tr>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody\n      *ngIf=\"data && !config.isLoading && config.rowReorder\"\n      class=\"ngx-draggable-row-area\"\n      cdkDropList\n      (cdkDropListDropped)=\"onDrop($event)\"\n    >\n      <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n        <ng-container\n          *ngFor=\"\n            let row of data\n              | sort: sortBy\n              | search: term:filteredCountSubject\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n            let rowIndex = index\n          \"\n        >\n          <tr class=\"ngx-draggable-row\" cdkDrag cdkDragLockAxis=\"y\">\n            <td *ngIf=\"config.checkboxes\">\n              <label class=\"ngx-form-checkbox\">\n                <input\n                  type=\"checkbox\"\n                  id=\"checkbox-draggable-{{ rowIndex }}\"\n                  [checked]=\"isSelected || selectedCheckboxes.has(rowIndex)\"\n                  (change)=\"onCheckboxSelect($event, row, rowIndex)\"\n                />\n                <em class=\"ngx-form-icon\"></em>\n              </label>\n            </td>\n            <td *ngIf=\"config.radio\">\n              <label>\n                <input\n                  type=\"radio\"\n                  id=\"radio-draggable-{{ rowIndex }}\"\n                  name=\"radio\"\n                  (change)=\"onRadioSelect($event, row, rowIndex)\"\n                />\n              </label>\n            </td>\n            <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n              <td\n                (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                [class.ngx-table__table-col--selected]=\"\n                  colIndex === selectedCol && !config.selectCell\n                \"\n                [class.ngx-table__table-cell--selected]=\"\n                  colIndex === selectedCol &&\n                  rowIndex === selectedRow &&\n                  !config.selectCol &&\n                  !config.selectRow\n                \"\n              >\n                <div>{{ row | render: column.key }}</div>\n              </td>\n            </ng-container>\n          </tr>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody *ngIf=\"filterCount === 0\">\n      <tr class=\"ngx-table__body-empty\">\n        <ng-container *ngIf=\"noResultsTemplate\" [ngTemplateOutlet]=\"noResultsTemplate\">\n        </ng-container>\n        <td [attr.colspan]=\"columns && columns.length + 1\" *ngIf=\"!noResultsTemplate\">\n          <div class=\"ngx-table__table-no-results\">\n            No results\n          </div>\n        </td>\n      </tr>\n    </tbody>\n    <tbody *ngIf=\"config.isLoading\">\n      <tr class=\"ngx-table__body-loading\">\n        <ng-container *ngIf=\"loadingTemplate\" [ngTemplateOutlet]=\"loadingTemplate\"> </ng-container>\n        <td [attr.colspan]=\"columns && columns.length + 1\" *ngIf=\"!loadingTemplate\">\n          <div [style.height.px]=\"loadingHeight\" class=\"ngx-table__table-loader-wrapper\">\n            <div class=\"ngx-table__table-loader\"></div>\n          </div>\n        </td>\n      </tr>\n    </tbody>\n    <tfoot *ngIf=\"summaryTemplate\">\n      <tr>\n        <ng-container\n          [ngTemplateOutlet]=\"summaryTemplate\"\n          [ngTemplateOutletContext]=\"{ total: data.length, limit: limit, page: page }\"\n        >\n        </ng-container>\n      </tr>\n    </tfoot>\n  </table>\n  <pagination\n    [attr.id]=\"'pagination' + id\"\n    [id]=\"id\"\n    #paginationComponent\n    [config]=\"config\"\n    [pagination]=\"pagination\"\n    (updateRange)=\"onPagination($event)\"\n  >\n  </pagination>\n</div>\n",
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __metadata("design:paramtypes", [ChangeDetectorRef,
            ScrollDispatcher,
            StyleService])
    ], BaseComponent);
    return BaseComponent;
}());

var HeaderComponent = /** @class */ (function () {
    function HeaderComponent() {
        this.update = new EventEmitter();
    }
    HeaderComponent.prototype.unifyKey = function (key) {
        return key.replace('.', '_');
    };
    HeaderComponent.prototype.onSearch = function (input) {
        this.update.emit([
            { value: input.value, key: this.column.key },
        ]);
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeaderComponent.prototype, "column", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeaderComponent.prototype, "update", void 0);
    HeaderComponent = __decorate([
        Component({
            selector: 'table-header',
            template: "<label for=\"search_{{ unifyKey(column.key) }}\">\n  <input type=\"text\"\n         id=\"search_{{ unifyKey(column.key) }}\"\n         aria-label=\"Search\"\n         placeholder=\"{{ column.placeholder ? column.placeholder : column.title }}\"\n         class=\"ngx-table__header-search\"\n         #input\n         (input)=\"onSearch(input)\"\n  >\n</label>\n",
            changeDetection: ChangeDetectionStrategy.OnPush
        })
    ], HeaderComponent);
    return HeaderComponent;
}());

var GlobalSearchPipe = /** @class */ (function () {
    function GlobalSearchPipe() {
    }
    GlobalSearchPipe.prototype.transform = function (array, filter, filteredCountSubject) {
        filteredCountSubject.next(0);
        if (typeof array === 'undefined') {
            return;
        }
        if (typeof filter === 'undefined' || Object.keys(filter).length === 0 || filter === '') {
            filteredCountSubject.next(array.length);
            return array;
        }
        var arr = array.filter(function (row) {
            var element = JSON.stringify(Object.values(row));
            var strings = filter.split(',');
            return strings.some(function (string) { return element.toLocaleLowerCase().indexOf(string.trim().toLocaleLowerCase()) > -1; });
        });
        filteredCountSubject.next(arr.length);
        return arr;
    };
    GlobalSearchPipe = __decorate([
        Pipe({
            name: 'global',
        })
    ], GlobalSearchPipe);
    return GlobalSearchPipe;
}());

var FiltersService = /** @class */ (function () {
    function FiltersService() {
    }
    FiltersService.getPath = function (p, o) {
        // https://github.com/dherges/ng-packagr/issues/696
        /* tslint:disable-next-line */
        var result = p.reduce(function (xs, x) { return (xs && typeof xs[x] !== 'undefined') ? xs[x] : null; }, o);
        return result;
    };
    FiltersService = __decorate([
        Injectable()
    ], FiltersService);
    return FiltersService;
}());

var RenderPipe = /** @class */ (function () {
    function RenderPipe() {
    }
    RenderPipe.prototype.transform = function (row, key) {
        var split = key.split('.');
        return FiltersService.getPath(split, row);
    };
    RenderPipe = __decorate([
        Pipe({
            name: 'render',
        })
    ], RenderPipe);
    return RenderPipe;
}());

var SearchPipe = /** @class */ (function () {
    function SearchPipe() {
        this.filters = {};
    }
    SearchPipe.prototype.transform = function (array, filter, filteredCountSubject, config) {
        var _this = this;
        filteredCountSubject.next(0);
        if (typeof array === 'undefined') {
            return;
        }
        if (typeof filter === 'undefined') {
            filteredCountSubject.next(array.length);
            return array;
        }
        filter.forEach(function (f) {
            _this.filters[f.key] = f.value.toString().toLocaleLowerCase();
            if (Object.keys(f).length === 0 || f.value === '') {
                delete _this.filters[f.key];
            }
        });
        if (config && config.groupRows) {
            return array.map(function (arr) { return _this.filterGroup(arr, filteredCountSubject); });
        }
        return this.filterGroup(array, filteredCountSubject);
    };
    SearchPipe.prototype.filterGroup = function (array, filteredCountSubject) {
        var _this = this;
        var arr = array.filter(function (obj) {
            return Object.keys(_this.filters).every(function (c) {
                var split = c.split('.');
                var val = FiltersService.getPath(split, obj);
                var element = (typeof val === 'object') ? JSON.stringify(val) : val.toString().toLocaleLowerCase();
                var strings = _this.filters[c].split(',');
                return strings.some(function (string) { return element.indexOf(string.trim()) > -1; });
            });
        });
        filteredCountSubject.next(arr.length);
        return arr;
    };
    SearchPipe = __decorate([
        Pipe({
            name: 'search',
        })
    ], SearchPipe);
    return SearchPipe;
}());

var SortPipe = /** @class */ (function () {
    function SortPipe() {
        this.defaultArray = [];
    }
    SortPipe_1 = SortPipe;
    SortPipe.isNaN = function (aV, bV) {
        return (isNaN(parseFloat(aV)) || !isFinite(aV)) || (isNaN(parseFloat(bV)) || !isFinite(bV));
    };
    SortPipe.compare = function (a, b, key) {
        var split = key.split('.');
        var aPath = FiltersService.getPath(split, a);
        var bPath = FiltersService.getPath(split, b);
        var aValue = (aPath + '').toLowerCase();
        var bValue = (bPath + '').toLowerCase();
        if (SortPipe_1.isNaN(aPath, bPath)) {
            return aValue.localeCompare(bValue);
        }
        else {
            if (parseFloat(aPath) < parseFloat(bPath)) {
                return -1;
            }
            if (parseFloat(aPath) > parseFloat(bPath)) {
                return 1;
            }
        }
        return 0;
    };
    SortPipe.prototype.transform = function (array, filter, config) {
        if (this.defaultArray.length === 0) {
            this.defaultArray = array;
        }
        if (!filter.key || filter.key === '') {
            return array;
        }
        if (filter.order === '') {
            return this.defaultArray;
        }
        if (filter.order === 'asc') {
            return this.sortAsc(array, filter, config);
        }
        else {
            return this.sortDesc(array, filter, config);
        }
    };
    SortPipe.prototype.sortAsc = function (array, filter, config) {
        if (config && config.groupRows) {
            return array.map(function (arr) { return arr.sort(function (a, b) { return SortPipe_1.compare(a, b, filter.key); }); });
        }
        return array.sort(function (a, b) { return SortPipe_1.compare(a, b, filter.key); });
    };
    SortPipe.prototype.sortDesc = function (array, filter, config) {
        if (config && config.groupRows) {
            return array.map(function (arr) { return arr.sort(function (a, b) { return SortPipe_1.compare(b, a, filter.key); }); });
        }
        return array.sort(function (a, b) { return SortPipe_1.compare(b, a, filter.key); });
    };
    var SortPipe_1;
    SortPipe = SortPipe_1 = __decorate([
        Pipe({
            name: 'sort',
        })
    ], SortPipe);
    return SortPipe;
}());

var TableTHeadComponent = /** @class */ (function () {
    function TableTHeadComponent(styleService) {
        this.styleService = styleService;
        this.menuActive = false;
        this.openedHeaderActionTemplate = null;
        this.onSelectAllBinded = this.onSelectAll.bind(this);
        this.filter = new EventEmitter();
        this.order = new EventEmitter();
        this.selectAll = new EventEmitter();
        this.event = new EventEmitter();
    }
    TableTHeadComponent.prototype.onClick = function (targetElement) {
        if (this.additionalActionMenu && !this.additionalActionMenu.nativeElement.contains(targetElement)) {
            this.menuActive = false;
        }
    };
    TableTHeadComponent.prototype.getColumnDefinition = function (column) {
        return column.searchEnabled || typeof column.searchEnabled === 'undefined';
    };
    TableTHeadComponent.prototype.orderBy = function (column) {
        this.order.emit(column);
    };
    TableTHeadComponent.prototype.isOrderEnabled = function (column) {
        var columnOrderEnabled = column.orderEnabled === undefined ? true : !!column.orderEnabled;
        return this.config.orderEnabled && columnOrderEnabled;
    };
    TableTHeadComponent.prototype.columnDrop = function (event) {
        moveItemInArray(this.columns, event.previousIndex, event.currentIndex);
    };
    TableTHeadComponent.prototype.onSearch = function ($event) {
        this.filter.emit($event);
    };
    TableTHeadComponent.prototype.getColumnWidth = function (column) {
        if (column.width) {
            return column.width;
        }
        return this.config.fixedColumnWidth ? 100 / this.columns.length + '%' : null;
    };
    TableTHeadComponent.prototype.onSelectAll = function () {
        this.selectAll.emit();
    };
    TableTHeadComponent.prototype.onMouseDown = function (event, th) {
        if (!this.config.resizeColumn) {
            return;
        }
        this.th = th;
        this.startOffset = th.offsetWidth - event.pageX;
        this.event.emit({
            event: Event.onColumnResizeMouseDown,
            value: event,
        });
    };
    TableTHeadComponent.prototype.onMouseMove = function (event) {
        if (!this.config.resizeColumn) {
            return;
        }
        if (this.th && this.th.style) {
            this.th.style.width = this.startOffset + event.pageX + 'px';
            this.th.style.cursor = 'col-resize';
            this.th.style['user-select'] = 'none';
        }
    };
    TableTHeadComponent.prototype.onMouseUp = function (event) {
        if (!this.config.resizeColumn) {
            return;
        }
        this.event.emit({
            event: Event.onColumnResizeMouseUp,
            value: event,
        });
        this.th.style.cursor = 'default';
        this.th = undefined;
    };
    TableTHeadComponent.prototype.showHeaderActionTemplateMenu = function (column) {
        if (!column.headerActionTemplate) {
            console.error('Column [headerActionTemplate] property not defined');
        }
        if (this.openedHeaderActionTemplate === column.key) {
            this.openedHeaderActionTemplate = null;
            return;
        }
        this.openedHeaderActionTemplate = column.key;
    };
    TableTHeadComponent.prototype.showMenu = function () {
        if (!this.additionalActionsTemplate) {
            console.error('[additionalActionsTemplate] property not defined');
        }
        this.menuActive = !this.menuActive;
    };
    TableTHeadComponent.ctorParameters = function () { return [
        { type: StyleService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "config", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], TableTHeadComponent.prototype, "columns", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "sortKey", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "sortState", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "selectAllTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "filtersTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], TableTHeadComponent.prototype, "additionalActionsTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "filter", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "order", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "selectAll", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "event", void 0);
    __decorate([
        ViewChild('th'),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "th", void 0);
    __decorate([
        ViewChild('additionalActionMenu'),
        __metadata("design:type", Object)
    ], TableTHeadComponent.prototype, "additionalActionMenu", void 0);
    __decorate([
        HostListener('document:click', ['$event.target']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], TableTHeadComponent.prototype, "onClick", null);
    TableTHeadComponent = __decorate([
        Component({
            selector: '[table-thead]',
            template: "<tr class=\"ngx-table__header\" *ngIf=\"config.headerEnabled && !config.columnReorder\">\n  <th *ngIf=\"config.checkboxes || config.radio\" [style.width]=\"'3%'\">\n    <ng-container\n      *ngIf=\"selectAllTemplate && config.checkboxes\"\n      [ngTemplateOutlet]=\"selectAllTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: onSelectAllBinded }\">\n    </ng-container>\n    <label class=\"ngx-form-checkbox\"\n           for=\"selectAllCheckboxes\"\n           *ngIf=\"!selectAllTemplate && config.checkboxes\">\n      <input type=\"checkbox\" id=\"selectAllCheckboxes\" (change)=\"onSelectAll()\">\n      <em class=\"ngx-form-icon\" id=\"selectAllCheckbox\"></em>\n    </label>\n  </th>\n  <ng-container *ngFor=\"let column of columns; let colIndex = index; let last = last\">\n    <th class=\"ngx-table__header-cell\"\n        [class.pinned-left]=\"column.pinned\"\n        [ngClass]=\"column.cssClass && column.cssClass.includeHeader ? column.cssClass.name : ''\"\n        [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n        #th\n        [style.width]=\"getColumnWidth(column)\"\n        (mousedown)=\"onMouseDown($event, th)\"\n        (mouseup)=\"onMouseUp($event)\"\n        (mousemove)=\"onMouseMove($event)\">\n      <div (click)=\"orderBy(column)\" style=\"display: inline\" [class.pointer]=\"isOrderEnabled(column)\">\n        <div class=\"ngx-table__header-title\">{{ column.title }}<span>&nbsp;</span>\n          <em class=\"ngx-icon ngx-icon-pin\" *ngIf=\"column.pinned\"></em>\n          <div [style.display]=\"config.orderEnabled ? 'inline' : 'none' \">\n            <em *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'asc'\"\n               class=\"ngx-icon ngx-icon-arrow-up\">\n            </em>\n            <em *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'desc'\"\n               class=\"ngx-icon ngx-icon-arrow-down\">\n            </em>\n          </div>\n        </div>\n      </div>\n      <div class=\"ngx-dropdown\"\n           *ngIf=\"!!column.headerActionTemplate\">\n        <a class=\"ngx-btn ngx-btn-link\" (click)=\"showHeaderActionTemplateMenu(column)\">\n          <span class=\"ngx-icon ngx-icon-more\"></span>\n        </a>\n        <div class=\"ngx-menu ngx-table__table-menu\"\n            *ngIf=\"column.key === openedHeaderActionTemplate\">\n          <ng-container\n            [ngTemplateOutlet]=\"column.headerActionTemplate\">\n          </ng-container>\n        </div>\n      </div>\n      <div class=\"ngx-table__column-resizer\" *ngIf=\"config.resizeColumn && !last\"></div>\n    </th>\n  </ng-container>\n  <th *ngIf=\"config.additionalActions || config.detailsTemplate || config.collapseAllRows || config.groupRows\"\n      class=\"ngx-table__header-cell-additional-actions\">\n    <div class=\"ngx-dropdown\"\n         #additionalActionMenu\n         *ngIf=\"config.additionalActions\">\n      <a class=\"ngx-btn ngx-btn-link\" (click)=\"showMenu()\">\n        <span class=\"ngx-icon ngx-icon-menu\"></span>\n      </a>\n      <ul class=\"ngx-menu ngx-table__table-menu\"\n          *ngIf=\"menuActive\">\n        <ng-container\n          *ngIf=\"additionalActionsTemplate\"\n          [ngTemplateOutlet]=\"additionalActionsTemplate\">\n        </ng-container>\n      </ul>\n    </div>\n  </th>\n</tr>\n<tr class=\"ngx-table__header ngx-table__header--draggable\"\n    *ngIf=\"config.headerEnabled && config.columnReorder\"\n    cdkDropList\n    cdkDropListOrientation=\"horizontal\"\n    (cdkDropListDropped)=\"columnDrop($event)\"\n>\n  <th [style.width]=\"'3%'\">\n    <ng-container\n      *ngIf=\"selectAllTemplate && config.checkboxes\"\n      [ngTemplateOutlet]=\"selectAllTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: onSelectAllBinded }\">\n    </ng-container>\n    <label class=\"ngx-form-checkbox\"\n           for=\"selectAllCheckboxes\"\n           *ngIf=\"!selectAllTemplate && config.checkboxes\">\n      <input type=\"checkbox\" id=\"selectAllCheckboxesDrag\" (change)=\"onSelectAll()\">\n      <em class=\"ngx-form-icon\" id=\"selectAllCheckboxDrag\"></em>\n    </label>\n  </th>\n  <ng-container *ngFor=\"let column of columns; let colIndex = index; let last = last\">\n    <th class=\"ngx-table__header-cell ngx-table__header-cell--draggable\"\n        cdkDragLockAxis=\"x\"\n        cdkDrag\n        [class.pinned-left]=\"column.pinned\"\n        [ngClass]=\"column.cssClass && column.cssClass.includeHeader ? column.cssClass.name : ''\"\n        [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n        #th\n        [style.width]=\"getColumnWidth(column)\"\n        (mousedown)=\"onMouseDown($event, th)\"\n        (mouseup)=\"onMouseUp($event)\"\n        (mousemove)=\"onMouseMove($event)\">\n      <div (click)=\"orderBy(column)\" style=\"display: inline\"\n           cdkDragHandle\n           [class.pointer]=\"isOrderEnabled(column)\">\n        <div class=\"ngx-table__header-title\">{{ column.title }}<span>&nbsp;</span>\n          <em class=\"ngx-icon ngx-icon-pin\" *ngIf=\"column.pinned\"></em>\n          <div [style.display]=\"config.orderEnabled ? 'inline' : 'none' \">\n            <em *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'asc'\"\n                class=\"ngx-icon ngx-icon-arrow-up\">\n            </em>\n            <em *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'desc'\"\n                class=\"ngx-icon ngx-icon-arrow-down\">\n            </em>\n          </div>\n        </div>\n      </div>\n      <div class=\"ngx-dropdown\"\n           *ngIf=\"!!column.headerActionTemplate\">\n        <a class=\"ngx-btn ngx-btn-link\" (click)=\"showHeaderActionTemplateMenu(column)\">\n          <span class=\"ngx-icon ngx-icon-more\"></span>\n        </a>\n        <div class=\"ngx-menu ngx-table__table-menu\"\n             *ngIf=\"column.key === openedHeaderActionTemplate\">\n          <ng-container\n            [ngTemplateOutlet]=\"column.headerActionTemplate\">\n          </ng-container>\n        </div>\n      </div>\n      <div class=\"ngx-table__column-resizer\" *ngIf=\"config.resizeColumn && !last\"></div>\n    </th>\n  </ng-container>\n  <th *ngIf=\"config.additionalActions || config.detailsTemplate || config.collapseAllRows || config.groupRows\"\n      class=\"ngx-table__header-cell-additional-actions\">\n    <div class=\"ngx-dropdown\"\n         #additionalActionMenu\n         *ngIf=\"config.additionalActions\">\n      <a class=\"ngx-btn ngx-btn-link\" (click)=\"showMenu()\">\n        <span class=\"ngx-icon ngx-icon-menu\"></span>\n      </a>\n      <ul class=\"ngx-menu ngx-table__table-menu\"\n          *ngIf=\"menuActive\">\n        <ng-container\n          *ngIf=\"additionalActionsTemplate\"\n          [ngTemplateOutlet]=\"additionalActionsTemplate\">\n        </ng-container>\n      </ul>\n    </div>\n  </th>\n</tr>\n<tr *ngIf=\"config.searchEnabled && !filtersTemplate\"\n    class=\"ngx-table__sort-header\">\n  <th *ngIf=\"config.checkboxes || config.radio\"></th>\n  <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n    <th\n      [ngClass]=\"column.cssClass && column.cssClass.includeHeader ? column.cssClass.name : ''\"\n      [class.pinned-left]=\"column.pinned\"\n      [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\">\n      <table-header\n        *ngIf=\"getColumnDefinition(column)\"\n        (update)=\"onSearch($event)\"\n        [column]=\"column\">\n      </table-header>\n    </th>\n  </ng-container>\n  <th *ngIf=\"config.additionalActions || config.detailsTemplate\"></th>\n</tr>\n<ng-container *ngIf=\"filtersTemplate\">\n  <tr>\n    <ng-container [ngTemplateOutlet]=\"filtersTemplate\">\n    </ng-container>\n  </tr>\n</ng-container>\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            providers: [StyleService],
            styles: ["\n    .cdk-drag-preview {\n      text-align: left;\n      padding-top: 9px;\n      padding-left: 4px;\n      color: #50596c;\n      border: 1px solid #e7e9ed;\n    }\n  "]
        }),
        __metadata("design:paramtypes", [StyleService])
    ], TableTHeadComponent);
    return TableTHeadComponent;
}());

var BaseModule = /** @class */ (function () {
    function BaseModule() {
    }
    BaseModule = __decorate([
        NgModule({
            declarations: [
                BaseComponent,
                HeaderComponent,
                PaginationComponent,
                TableTHeadComponent,
                // Pipes
                SearchPipe,
                RenderPipe,
                GlobalSearchPipe,
                SortPipe,
            ],
            imports: [
                CommonModule,
                NgxPaginationModule,
                DragDropModule,
                ScrollingModule,
            ],
            exports: [BaseComponent],
        })
    ], BaseModule);
    return BaseModule;
}());

var TableModule = /** @class */ (function () {
    function TableModule() {
    }
    TableModule = __decorate([
        NgModule({
            imports: [CommonModule, BaseModule],
            exports: [BaseComponent],
            providers: [],
        })
    ], TableModule);
    return TableModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { API, BaseComponent, DefaultConfig, Event, STYLE, THEME, TableModule, DefaultConfigService as a, BaseModule as b, GroupRowsService as c, StyleService as d, HeaderComponent as e, PaginationComponent as f, TableTHeadComponent as g, SearchPipe as h, RenderPipe as i, GlobalSearchPipe as j, SortPipe as k };
//# sourceMappingURL=ngx-easy-table.js.map
